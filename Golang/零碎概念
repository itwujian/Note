golang 中有两个内存分配机制 ：new和make，二者有明显区别．

　　new：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。其自身是一个指针．可用于初始化任何类型
　　make: 返回一个有初始值(非零)的T类型，而不是*T，其只能用来初始化：slice,map和channel三种类型。

对比：
适用范围：make 只能创建内建类型(slice map channel)， new 则是可以对所有类型进行内存分配
返回值： new 返回指针， make 返回引用
填充值： new 填充零值， make 填充非零值

指针和引用的区别:
　　相同点：
　　　　都是地址的概念
　　　　指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
　　不同点：
　　　　指针是一个实体，而引用仅是个别名
　　　　引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
　　　　引用是类型安全的，而指针不是 (引用比指针多了类型检查
 
指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，
从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。
（这里是在说实参指针本身的地址值不会变）
 
而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（int &a的形式）。
被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。
正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
